# ğŸ“˜ BridgeLabz Training â€“ Data Structures & Algorithms (DSA)

---

## ğŸ“… Week 3 â€“ Day 1: Linked Lists Using Java

On **Day 1 of Week 3**, I focused on **Data Structures (Linked Lists)** using Java.
The session involved understanding **node-based storage, pointer manipulation, traversal logic**, and solving **real-world scenario-based problems** with Linked Lists.

ğŸ”— **Code Link â€“ Day 1:**
ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/linkedlist](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/linkedlist)

---

## ğŸ§  Best Practices Applied

* Maintained **head & tail pointers** for efficient access
* Performed **null checks** before operations
* Ensured **O(1)** insertion/deletion at ends
* Handled edge cases (empty list, head/tail manipulations)
* Prevented infinite loops in circular lists
* Clean pointer updates & memory safety
* Modular and readable method design

---

## ğŸ”¹ Implementations Completed

### 1ï¸âƒ£ Singly Linked List â€“ Student Record Management

* Add, delete, search, update student records
* Display all records

### 2ï¸âƒ£ Doubly Linked List â€“ Movie Management System ğŸ¬

* Add, remove, search, update movies
* Forward & reverse display

### 3ï¸âƒ£ Circular Linked List â€“ Task Scheduler â±ï¸

* Add/remove tasks
* Cyclic traversal
* Search by priority

### 4ï¸âƒ£ Singly Linked List â€“ Inventory Management ğŸ“¦

* Add/remove/search items
* Update quantity
* Calculate total inventory value
* Sort items by name or price

### 5ï¸âƒ£ Doubly Linked List â€“ Library Management System ğŸ“š

* Add/remove books
* Search by title/author
* Update availability
* Forward & reverse display

### 6ï¸âƒ£ Circular Linked List â€“ Round Robin Scheduling ğŸ–¥ï¸

* CPU scheduling simulation
* Time quantum execution logic
* Average waiting & turnaround time

### 7ï¸âƒ£ Singly Linked List â€“ Social Media Friend Connections ğŸŒ

* Manage friend connections
* Find mutual friends
* Search users & count connections

### 8ï¸âƒ£ Doubly Linked List â€“ Undo/Redo Text Editor âœï¸

* Undo/redo text states
* Limited history support

### 9ï¸âƒ£ Circular Linked List â€“ Online Ticket Reservation ğŸŸï¸

* Add/remove tickets
* Search by customer/movie
* Display all bookings

---

## ğŸ›  Tools & Workflow

* **Java (Core Java)**
* **Eclipse IDE**
* **Git & GitHub**
* Manual DSA implementation (no collections)

---

# ğŸ“… Week 3 â€“ Day 2: Stacks & Queues Using Java

On **Day 2 of Week 3**, I focused on **Data Structures (Stacks & Queues)** using Java.
The session emphasized **LIFO/FIFO principles**, **auxiliary data structures**, and solving **classic interview-level problems** using stacks, queues, deques, and hash-based optimizations.

ğŸ”— **Code Link â€“ Day 2:**
ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com)

---

## ğŸ§  Best Practices Applied

* Used **Stack, Queue, Deque** appropriately based on problem needs
* Avoided unnecessary extra data structures
* Maintained **O(n)** optimized solutions where possible
* Handled **edge cases** (empty stack/queue, underflow, overflow)
* Clean separation of logic into helper methods
* Proper use of **Java Collections Framework**
* Focused on **readability and exam-friendly code structure**

---

## ğŸ”¹ Implementations Completed

### 1ï¸âƒ£ Stack â€“ Sort a Stack Using Recursion ğŸ”

* Sorted stack elements using **pure recursion**
* No extra stack used
* Demonstrated recursive backtracking

---

### 2ï¸âƒ£ Stack â€“ Stock Span Problem ğŸ“ˆ

* Calculated stock span for each day
* Used stack to track previous greater elements
* Achieved **O(n)** time complexity

---

### 3ï¸âƒ£ Queue / Deque â€“ Sliding Window Maximum ğŸªŸ

* Found maximum element in each window of size `k`
* Used **Deque** to maintain useful indices
* Optimized over brute-force approach

---

### 4ï¸âƒ£ Queue â€“ Circular Tour (Petrol Pump) Problem â›½

* Determined valid starting point for circular tour
* Implemented solution using **Queue**
* Tracked petrol surplus and eliminated invalid starts

---

### 5ï¸âƒ£ Stack â€“ Queue Implementation Using Two Stacks ğŸ”„

* Implemented Queue behavior using Stack operations
* Practiced **data structure transformation**
* Demonstrated enqueue and dequeue logic

---

### 6ï¸âƒ£ Stack â€“ Balanced & Logical Stack Operations ğŸ§±

* Push, pop, peek operations
* Proper size and boundary handling
* Clear understanding of LIFO behavior

---

## ğŸ§© Key Concepts Strengthened

* Stack vs Queue use-cases
* Recursion with stack memory
* Sliding window technique
* Circular traversal logic
* Real-world problem modeling using abstract data structures
* Time & space complexity awareness

---


## ğŸ“˜ Week 3 â€“ Day 3: Strings, File Handling, Searching & Sorting in Java

On **Day 3 of Week 3**, I worked on **string manipulation**, **file I/O**, **searching techniques**, and **sorting algorithms** in Java with a focus on **best practices** and **interview-level problem solving**.

---

## ğŸ§  Key Concepts & Best Practices

### ğŸ”¹ String Handling

* Used **StringBuilder** for high-performance mutable strings
* Used **StringBuffer** for thread-safe operations
* Wrapped readers (FileReader / InputStreamReader) with **BufferedReader**

### ğŸ”¹ Searching Techniques

* **Linear Search** for unsorted data
* **Binary Search** for sorted data (overflow-safe mid calculation)

### ğŸ”¹ Sorting Algorithms

* **Bubble, Selection, Insertion**
* **Merge, Quick, Heap, Counting**
* Emphasis on **correct logic**, **time complexity**, and **use cases**

---

## ğŸ§ª Problems Solved

### ğŸ”¤ StringBuilder & StringBuffer

* Reverse string using StringBuilder
* Remove duplicates
* Efficient concatenation
* Performance comparison

### ğŸ“ File Handling

* Read file line-by-line
* Word occurrence count
* Convert byte stream to characters
* Console input write to file

### ğŸ” Searching

* First negative number
* Word search in sentences
* Rotation point in rotated array
* Peak element
* 2D matrix binary search
* First & last occurrence
* Combined linear & binary challenge

### ğŸ”ƒ Sorting

* Student marks (Bubble Sort)
* Employee IDs (Insertion Sort)
* Exam scores (Selection Sort)
* Book prices (Merge Sort)
* Product prices (Quick Sort)
* Salaries (Heap Sort)
* Student ages (Counting Sort)

---

## ğŸ”— Code Links

### ğŸ“‚ Searching Algorithms

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/binarysearch](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/binarysearch)

### ğŸ“‚ Sorting Algorithms

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/sortingalgorithm](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/sortingalgorithm)

---

## ğŸ›  Tools & Workflow

* **Java (Core)**
* **Eclipse IDE**
* **Git & GitHub**
* Clean, modular, interview-prepared code

---

## ğŸ“˜ Week 3 â€“ Day 4: Runtime Analysis & Big-O Optimization in Java

On **Day 4 of Week 3**, I focused on **Runtime Analysis and Big-O Notation**, comparing **time and space complexity** of different algorithms and data structures through **practical, performance-driven problems**.

The emphasis was on **choosing efficient algorithms**, **reducing unnecessary computations**, and **writing scalable Java code**.

---

## ğŸ§  Key Concepts & Best Practices

### ğŸ”¹ Algorithm Design & Optimization

* Selected the **right data structure** for performance
* Avoided unnecessary **nested loops**
* Used **early exit (break/return)** where applicable
* Reduced redundant computations using caching/memoization
* Preferred **iterative solutions** over expensive recursion

---

### ğŸ”¹ Time & Space Complexity Techniques

* Used **Binary Search (O(log N))** over Linear Search (O(N))
* Preferred **Merge Sort / Quick Sort (O(N log N))** over Bubble Sort
* Used **StringBuilder** instead of `String` for concatenation
* Used **primitive data types** to reduce memory overhead
* Benchmarked performance using `System.nanoTime()`

---

## ğŸ§ª Problems & Performance Comparisons

### ğŸ” Searching Large Datasets

* Linear Search vs Binary Search
* Observed drastic performance improvement with sorted data

---

### ğŸ”ƒ Sorting Large Data

* Bubble Sort vs Merge Sort vs Quick Sort
* Identified Bubble Sort as impractical for large datasets

---

### ğŸ”¤ String Concatenation Performance

* `String` vs `StringBuilder` vs `StringBuffer`
* Confirmed **StringBuilder** as best for single-threaded use

---

### ğŸ“ Large File Reading

* FileReader vs InputStreamReader
* InputStreamReader proved faster for large files

---

### ğŸ” Fibonacci Computation

* Recursive (O(2â¿)) vs Iterative (O(N))
* Iterative approach significantly faster and memory-efficient

---

### ğŸ—‚ Data Structure Lookup Comparison

* Array vs HashSet vs TreeSet
* HashSet fastest for search, TreeSet for ordered data

---

## ğŸ“Œ Learning Outcomes

âœ” Strong understanding of Big-O notation
âœ” Ability to compare algorithm efficiency
âœ” Improved decision-making for data structures
âœ” Optimized Java programs for scalability
âœ” Interview-ready runtime analysis skills

---

## ğŸ”— Code Link â€“ Runtime Analysis & Big-O

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/algoritmsruntimeanalysis](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/algoritmsruntimeanalysis)

---

## ğŸ“˜ Week 3 â€“ Day 5: Scenario-Based Data Structures in Java

On **Day 5 of Week 3**, I focused on implementing **scenario-based Data Structure problems** using Java.
The goal was to model **real-world systems** using **Circular Linked Lists, HashMaps, LinkedLists, and Sets**, emphasizing **efficient traversal, insertion, deletion, and lookup operations**.

---

## ğŸ§  Key Data Structures & Concepts Applied

### ğŸ”¹ Circular Linked List

* Used for **cyclic traversal** without a fixed start/end
* Ideal for round-robin and continuous navigation problems
* Handled safe removal of nodes during traversal

### ğŸ”¹ HashMap + LinkedList

* HashMap for **O(1)** category-based access
* LinkedList for **dynamic insertion and deletion**
* Combined structures for scalable data organization

### ğŸ”¹ Optional Optimization

* Used **HashSet** to prevent duplicate entries
* Improved data consistency and lookup performance

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸš‘ AmbulanceRoute â€“ Emergency Patient Navigation

*(Circular Linked List)*

**Scenario:**
Hospital units are connected in a circular path:
Emergency â†’ Radiology â†’ Surgery â†’ ICU â†’ Emergency

**Implementation Highlights:**

* Each node represents a hospital unit
* Circular traversal to find the **nearest available unit**
* Simulated patient redirection in emergency situations
* Removed units dynamically when under maintenance
* Ensured infinite-loop-safe traversal

---

### ğŸ“š BookShelf â€“ Library Organizer

*(HashMap + LinkedList)*

**Scenario:**
Library books organized by **genre and author**.

**Implementation Highlights:**

* `HashMap<Genre, LinkedList<Book>>` structure
* Genre-wise book catalog management
* Efficient book insert, delete, borrow, and return operations
* Optional `HashSet` used to avoid duplicate books
* Dynamic updates without reorganization overhead

---

## ğŸ”— Code Link â€“ Scenario-Based DSA

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

---

## ğŸ“˜ Week 3 â€“ Day 6: Linked List & Stack Applications in Java

On **Day 6 of Week 3**, I worked on **scenario-based Linked List problems** and **classic Linked List interview challenges** using Java.
The focus was on **navigation logic, pointer manipulation, stack usage**, and **efficient traversal techniques**.

---

## ğŸ§  Key Data Structures & Concepts Applied

### ğŸ”¹ Doubly Linked List

* Bidirectional traversal using `prev` and `next` pointers
* Efficient backward and forward navigation
* Memory-efficient pointer management

### ğŸ”¹ Stack

* Used for **undo/restore operations**
* Ideal for tracking recently closed elements
* LIFO-based recovery logic

### ğŸ”¹ Singly Linked List

* Traversal-based logic
* Node comparison and pointer reversal
* Edge case handling (empty list, single node)

---

## ğŸ› ï¸ Scenario-Based Implementation

### ğŸŒ BrowserBuddy â€“ Tab History Manager

*(Doubly Linked List + Stack)*

**Scenario:**
A custom browser where each tab maintains browsing history with **Back** and **Forward** operations, along with the ability to restore recently closed tabs.

**Implementation Highlights:**

* Doubly Linked List to maintain browsing history
* Supported **forward and backward navigation**
* Stack used to store recently closed tabs
* Restore closed tabs using LIFO behavior
* Pointer-based navigation for memory efficiency
* Clean handling of edge cases (no back/forward history)

---

## ğŸ§ª LeetCode Practice Problems Solved

### 1ï¸âƒ£ Remove Duplicates from Linked List

* Traversed the list to remove duplicate nodes
* Ensured only unique values remain
* Efficient pointer adjustment without extra memory

### 2ï¸âƒ£ Check if a Linked List is Palindrome

* Used fast & slow pointer technique
* Reversed second half of the list
* Compared both halves node by node
* Optimized for **O(N) time** and **O(1) space**

---

## ğŸ”— Code Links â€“ LeetCode & Scenario Problems

ğŸ‘‰ **Scenario-Based DSA:**
[https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

ğŸ‘‰ **LeetCode Practice Solutions:**
[https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/leet-code-based](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/leet-code-based)

---

## ğŸ“˜ Week 3 â€“ Day 7: Linked List & Stack Applications in Java

On **Day 7 of Week 3**, I worked on **scenario-based Data Structure problems** using **Queues, Priority Queues, Circular Linked Lists, Doubly Linked Lists, HashMaps, and Stacks**.
The focus was on **real-world system simulation**, **dynamic data flow**, and **efficient state management**.

---

## ğŸ§  Key Data Structures & Concepts Applied

### ğŸ”¹ Queue & Priority Queue

* FIFO call and vehicle management
* Priority handling for VIP users
* Overflow and underflow validation

### ğŸ”¹ Circular Linked List

* Continuous traversal without start/end
* Ideal for roundabouts and cyclic systems
* Safe insertion and removal of nodes

### ğŸ”¹ Doubly Linked List

* Forward and backward navigation
* Dynamic insertion and deletion
* Efficient neighbor access

### ğŸ”¹ HashMap + LinkedList

* O(1) category-based access
* Dynamic updates using LinkedList
* Optional HashSet to prevent duplicates

### ğŸ”¹ Stack

* Undo/Redo operations
* LIFO-based state recovery
* Separate stacks for undo and redo

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ“ CallCenter â€“ Customer Queue Manager

*(Queue + Priority Queue + HashMap)*

* Managed incoming calls using Queue
* VIP customers handled via Priority Queue
* HashMap tracked monthly call frequency
* Efficient dispatch and customer analytics

---

### ğŸš† TrainCompanion â€“ Compartment Navigation System

*(Doubly Linked List)*

* Train compartments modeled as nodes
* Forward and backward traversal supported
* Dynamic insert/remove of compartments
* Displayed adjacent compartments

---

### âœï¸ TextEditor â€“ Undo/Redo Functionality

*(Stack)*

* Insert and delete actions pushed to stack
* Undo using pop()
* Redo handled via separate stack
* Clean action restoration logic

---

### ğŸš¦ TrafficManager â€“ Roundabout Vehicle Flow

*(Circular Linked List + Queue)*

**Scenario:**
A smart city roundabout where vehicles enter, circulate, and exit dynamically.

**Implementation Highlights:**

* Vehicles represented as nodes in a Circular Linked List
* Continuous rotation through the roundabout
* Queue managed vehicles waiting to enter
* Handled queue overflow and underflow cases
* Printed real-time state of the roundabout

---

### ğŸ“š BookShelf â€“ Library Organizer

*(HashMap + LinkedList + HashSet)*

**Scenario:**
Library books organized by genre and author.

**Implementation Highlights:**

* `HashMap<Genre, LinkedList<Book>>` structure
* Genre-wise catalog maintenance
* Efficient insert, delete, borrow, and return
* Optional HashSet used to avoid duplication
* Dynamic updates without reorganization

---

## ğŸ”— Code Link â€“ Scenario-Based DSA

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

---

## ğŸ“˜ Week 3 â€“ Day 8: Queue, Linked List & Stackâ€“Map Systems in Java

On **Day 8 of Week 3**, I implemented **scenario-based Data Structure problems** using **Queues, Singly Linked Lists, Stacks, and HashMaps**.
The focus was on **real-time processing, sequential workflows, navigation tracking**, and **efficient data lookup**.

---

## ğŸ§  Key Data Structures & Concepts Applied

### ğŸ”¹ Queue

* FIFO-based customer and process management
* Efficient enqueue and dequeue operations
* Real-time flow control

### ğŸ”¹ Singly Linked List

* Forward-only traversal modeling step-by-step workflows
* Dynamic insertion of intermediate nodes
* Safe handling of null pointers

### ğŸ”¹ Stack

* LIFO-based navigation tracking
* Ideal for backtracking and review systems

### ğŸ”¹ HashMap

* O(1) data retrieval
* Fast lookup for pricing and answers
* Combined with other structures for hybrid systems

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ›’ SmartCheckout â€“ Supermarket Billing Queue

*(Queue + HashMap)*

**Scenario:**
Supermarket checkout counters manage customer billing efficiently.

**Implementation Highlights:**

* Queue maintained customer order
* HashMap used for item price and stock lookup
* Added and removed customers dynamically
* Updated stock levels after purchase
* Efficient billing workflow simulation

---

### ğŸ“¦ ParcelTracker â€“ Delivery Chain Management

*(Singly Linked List)*

**Scenario:**
Courier parcels tracked through delivery stages:
Packed â†’ Shipped â†’ In Transit â†’ Delivered

**Implementation Highlights:**

* Each stage represented as a node
* Forward traversal through delivery process
* Supported insertion of custom checkpoints
* Handled missing/lost parcels safely using null checks

---

### ğŸ“ ExamProctor â€“ Online Exam Review System

*(Stack + HashMap + Functions)*

**Scenario:**
Online exam system tracking student navigation and answers.

**Implementation Highlights:**

* Stack recorded question navigation history
* HashMap stored answers (`questionId â†’ answer`)
* Auto-evaluation using scoring functions
* Efficient review and submission workflow
* Clean separation of navigation and evaluation logic

---

## ğŸ”— Code Link â€“ Scenario-Based DSA

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

---

## ğŸ“˜ Week 3 â€“ Day 9: Sorting Algorithms | Real-World Data Ordering Systems in Java

On **Day 9 of Week 3**, I worked on **scenario-based sorting problems** using **classic and efficient sorting algorithms** in Java.
The focus was on **choosing the right sorting technique based on data size, order, and real-time requirements**.

---

## ğŸ§  Key Sorting Concepts Applied

### ğŸ”¹ Bubble Sort

* Best suited for **small datasets**
* In-place sorting with no extra memory
* Simple adjacent comparisons and swaps

### ğŸ”¹ Insertion Sort

* Ideal for **nearly sorted or real-time data**
* Online sorting (elements added one by one)
* Stable and efficient for small lists

### ğŸ”¹ Merge Sort

* Divide-and-conquer strategy
* Efficient for **large datasets**
* Stable sorting preserving relative order

### ğŸ”¹ Quick Sort

* Fast average-case performance
* Efficient for ranking and top-K problems
* Used for large-scale sorting scenarios

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ¥ HospitalQueue â€“ Patient Sorting by Criticality

*(Bubble Sort)*

**Scenario:**
ER patients are sorted by **criticality level (1â€“10)** before bed assignment.

**Highlights:**

* Small dataset (10â€“20 patients)
* In-place sorting without extra memory
* Adjacent comparison and swapping
* Efficient for short, frequently updated lists

---

### ğŸ“š SmartShelf â€“ Real-Time Book Arrangement

*(Insertion Sort)*

**Scenario:**
Digital library kiosk maintains books **sorted alphabetically** as users add them.

**Highlights:**

* Real-time insertion
* Efficient for nearly sorted data
* Stable sorting by book title
* Minimal shifting operations

---

### ğŸ›’ ZipZipMart â€“ Daily Sales Summary Report

*(Merge Sort)*

**Scenario:**
Thousands of daily sales transactions sorted by **date and amount**.

**Highlights:**

* Divide-and-conquer approach
* Handles large datasets efficiently
* Stable sorting preserves equal records order
* Ideal for report generation

---

### ğŸŸï¸ EventManager â€“ Ticket Price Optimizer

*(Quick Sort)*

**Scenario:**
Event booking portal sorts **millions of tickets by price** to display top 50 deals.

**Highlights:**

* Fast average performance
* Efficient ranking and filtering
* Suitable for large-scale datasets
* Optimized ticket price visibility

---

## ğŸ”— Code Link â€“ Sorting Scenarios (DSA)

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com/sortingalgorithms](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com/sortingalgorithms)

---

## ğŸ“˜ Week 3 â€“ Day 10: Incremental & Large-Scale Sorting Systems in Java

On **Day 10 of Week 3**, I worked on **scenario-based sorting systems** that required **real-time updates**, **streaming data handling**, and **large-scale list merging**.
The focus was on **choosing sorting algorithms based on data arrival pattern, dataset size, and performance needs**.

---

## ğŸ§  Key Sorting Techniques Applied

### ğŸ”¹ Insertion Sort

* Ideal for **incremental and streaming data**
* Efficient for **nearly sorted lists**
* Low memory footprint
* Simple and stable behavior

### ğŸ”¹ Merge Sort

* Best for **large datasets from multiple sources**
* Efficient merging of already sorted sublists
* Stable and predictable performance

### ğŸ”¹ Bubble Sort

* Suitable for **very small datasets**
* Simple logic for manual updates
* In-place sorting with minimal complexity

### ğŸ”¹ Quick Sort

* Fast average-case performance
* Efficient for **large, unordered datasets**
* Partition-based high-speed sorting

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ¨ ArtExpo â€“ Sort Artists by Registration Time

*(Insertion Sort)*

**Scenario:**
Artists register continuously during an exhibition day.

**Highlights:**

* Maintained sorted list by registration time
* Real-time insertion of new artists
* Efficient handling of nearly sorted data
* Ideal for incremental booth assignment

---

### ğŸ¤– RoboWarehouse â€“ Shelf Loading Robot

*(Insertion Sort)*

**Scenario:**
A warehouse robot loads packages one-by-one based on weight.

**Highlights:**

* Inserted packages dynamically into sorted list
* Maintained ascending weight order
* Low memory usage
* Ideal for streaming insertions

---

### ğŸšš FleetManager â€“ Vehicle Maintenance Scheduler

*(Merge Sort)*

**Scenario:**
Multiple depots send sorted vehicle mileage lists.

**Highlights:**

* Merged sorted sublists into a master schedule
* Efficient handling of large datasets
* Preserved ordering across depots
* Scalable scheduling solution

---

### ğŸ¬ CinemaHouse â€“ Movie Time Sorting

*(Bubble Sort)*

**Scenario:**
Local cinema manages a small list of daily showtimes.

**Highlights:**

* Simple adjacent swapping logic
* Small dataset (~10 shows)
* Easy manual updates
* Minimal code complexity

---

### ğŸŒ¾ CropMonitor â€“ Sensor Data Ordering

*(Quick Sort)*

**Scenario:**
Drone sensors generate large, unordered timestamp data.

**Highlights:**

* High-speed sorting by timestamp
* Efficient partition-based approach
* Optimized for large, unordered datasets
* Prepared data for visualization pipelines

---

## ğŸ”— Code Link â€“ Scenario-Based Sorting (DSA)

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

---

## ğŸ“˜ Week 3 â€“ Day 11: Real-World Sorting Systems | Small-Scale & Incremental Data in Java

On **Day 11 of Week 3**, I implemented **real-world, scenario-based sorting problems** using **Bubble Sort** and **Insertion Sort**.
The focus was on **small datasets**, **manual updates**, and **incremental data insertion**, where **simplicity, stability, and low overhead** are more important than complex optimizations.

---

## ğŸ§  Key Sorting Techniques Applied

### ğŸ”¹ Bubble Sort

* Best suited for **very small datasets**
* Simple logic with adjacent comparisons
* In-place sorting without extra memory
* Easy to implement and debug

### ğŸ”¹ Insertion Sort

* Ideal for **incremental data insertion**
* Efficient for **nearly sorted lists**
* Stable sorting behavior
* Low memory footprint

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ¦ IceCreamRush â€“ Sorting Flavors by Popularity

*(Bubble Sort)*

**Scenario:**
A small ice cream vendor tracks weekly sales of **8 flavors** and manually updates popularity rankings.

**Highlights:**

* Sorted flavors based on sales count
* Repeated adjacent comparisons
* In-place swapping without extra memory
* Ideal for short, manually maintained lists

---

### ğŸ“š SmartLibrary â€“ Auto-Sort Borrowed Books

*(Insertion Sort)*

**Scenario:**
A digital library kiosk maintains a userâ€™s borrowed books list, keeping it **alphabetically sorted** as new books are issued.

**Highlights:**

* Dynamic insertion of new books
* Maintained sorted order after each addition
* Efficient handling of nearly sorted data
* Stable sorting by book title

---

## ğŸ“˜ Week 3 â€“ Day 12: Scenario-Based Sorting Systems | Large & Small Scale Data in Java

On **Day 12 of Week 3**, I worked on **scenario-based DSA problems** focused on **sorting large datasets efficiently** and **handling small, frequently updated lists**.
The emphasis was on **algorithm selection based on data size, update frequency, and performance requirements**.

---

## ğŸ§  Key Sorting Algorithms Applied

### ğŸ”¹ Merge Sort

* Ideal for **large datasets**
* Efficiently merges **pre-sorted sublists**
* Stable sorting for duplicate values

### ğŸ”¹ Quick Sort

* Fast **average-case performance**
* Suitable for **large, unordered datasets**
* Optimized for ranking and filtering use cases

### ğŸ”¹ Bubble Sort

* Best for **small datasets**
* Simple logic for **frequent re-sorting**
* In-place sorting with minimal overhead

---

## ğŸ› ï¸ Scenario-Based Implementations

### ğŸ“ EduResults â€“ Rank Sheet Generator

*(Merge Sort)*

**Scenario:**
An education board merges sorted student score lists from multiple districts to generate a **state-wide rank list**.

**Highlights:**

* Merged multiple sorted sublists
* Maintained stable ordering for equal scores
* Efficient handling of thousands of records
* Suitable for large-scale academic data processing

---

### ğŸ›’ FlashDealz â€“ Product Sorting by Discount

*(Quick Sort)*

**Scenario:**
An e-commerce platform sorts **millions of products** during flash sales to show top discounts instantly.

**Highlights:**

* Sorted large, unsorted datasets
* Fast ranking of discounted products
* Optimized backend performance
* Ideal for real-time high-traffic systems

---

### ğŸƒ FitnessTracker â€“ Daily Step Count Ranking

*(Bubble Sort)*

**Scenario:**
A fitness app ranks usersâ€™ daily step counts in a **small group (<20 users)** with frequent updates.

**Highlights:**

* Simple adjacent comparison logic
* Efficient for small, frequently changing lists
* Real-time leaderboard updates
* Minimal code complexity

---

## ğŸ”— Code Link â€“ Scenario-Based Sorting (DSA)

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/ScenarioBasedQuestions/src/com)

