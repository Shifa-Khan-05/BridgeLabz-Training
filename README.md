# ğŸ“˜ BridgeLabz Training â€“ Data Structures & Algorithms (DSA)

---

## ğŸ“… Week 3 â€“ Day 1: Linked Lists Using Java

On **Day 1 of Week 3**, I focused on **Data Structures (Linked Lists)** using Java.
The session involved understanding **node-based storage, pointer manipulation, traversal logic**, and solving **real-world scenario-based problems** with Linked Lists.

ğŸ”— **Code Link â€“ Day 1:**
ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/linkedlist](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/linkedlist)

---

## ğŸ§  Best Practices Applied

* Maintained **head & tail pointers** for efficient access
* Performed **null checks** before operations
* Ensured **O(1)** insertion/deletion at ends
* Handled edge cases (empty list, head/tail manipulations)
* Prevented infinite loops in circular lists
* Clean pointer updates & memory safety
* Modular and readable method design

---

## ğŸ”¹ Implementations Completed

### 1ï¸âƒ£ Singly Linked List â€“ Student Record Management

* Add, delete, search, update student records
* Display all records

### 2ï¸âƒ£ Doubly Linked List â€“ Movie Management System ğŸ¬

* Add, remove, search, update movies
* Forward & reverse display

### 3ï¸âƒ£ Circular Linked List â€“ Task Scheduler â±ï¸

* Add/remove tasks
* Cyclic traversal
* Search by priority

### 4ï¸âƒ£ Singly Linked List â€“ Inventory Management ğŸ“¦

* Add/remove/search items
* Update quantity
* Calculate total inventory value
* Sort items by name or price

### 5ï¸âƒ£ Doubly Linked List â€“ Library Management System ğŸ“š

* Add/remove books
* Search by title/author
* Update availability
* Forward & reverse display

### 6ï¸âƒ£ Circular Linked List â€“ Round Robin Scheduling ğŸ–¥ï¸

* CPU scheduling simulation
* Time quantum execution logic
* Average waiting & turnaround time

### 7ï¸âƒ£ Singly Linked List â€“ Social Media Friend Connections ğŸŒ

* Manage friend connections
* Find mutual friends
* Search users & count connections

### 8ï¸âƒ£ Doubly Linked List â€“ Undo/Redo Text Editor âœï¸

* Undo/redo text states
* Limited history support

### 9ï¸âƒ£ Circular Linked List â€“ Online Ticket Reservation ğŸŸï¸

* Add/remove tickets
* Search by customer/movie
* Display all bookings

---

## ğŸ›  Tools & Workflow

* **Java (Core Java)**
* **Eclipse IDE**
* **Git & GitHub**
* Manual DSA implementation (no collections)

---

# ğŸ“… Week 3 â€“ Day 2: Stacks & Queues Using Java

On **Day 2 of Week 3**, I focused on **Data Structures (Stacks & Queues)** using Java.
The session emphasized **LIFO/FIFO principles**, **auxiliary data structures**, and solving **classic interview-level problems** using stacks, queues, deques, and hash-based optimizations.

ğŸ”— **Code Link â€“ Day 2:**
ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com)

---

## ğŸ§  Best Practices Applied

* Used **Stack, Queue, Deque** appropriately based on problem needs
* Avoided unnecessary extra data structures
* Maintained **O(n)** optimized solutions where possible
* Handled **edge cases** (empty stack/queue, underflow, overflow)
* Clean separation of logic into helper methods
* Proper use of **Java Collections Framework**
* Focused on **readability and exam-friendly code structure**

---

## ğŸ”¹ Implementations Completed

### 1ï¸âƒ£ Stack â€“ Sort a Stack Using Recursion ğŸ”

* Sorted stack elements using **pure recursion**
* No extra stack used
* Demonstrated recursive backtracking

---

### 2ï¸âƒ£ Stack â€“ Stock Span Problem ğŸ“ˆ

* Calculated stock span for each day
* Used stack to track previous greater elements
* Achieved **O(n)** time complexity

---

### 3ï¸âƒ£ Queue / Deque â€“ Sliding Window Maximum ğŸªŸ

* Found maximum element in each window of size `k`
* Used **Deque** to maintain useful indices
* Optimized over brute-force approach

---

### 4ï¸âƒ£ Queue â€“ Circular Tour (Petrol Pump) Problem â›½

* Determined valid starting point for circular tour
* Implemented solution using **Queue**
* Tracked petrol surplus and eliminated invalid starts

---

### 5ï¸âƒ£ Stack â€“ Queue Implementation Using Two Stacks ğŸ”„

* Implemented Queue behavior using Stack operations
* Practiced **data structure transformation**
* Demonstrated enqueue and dequeue logic

---

### 6ï¸âƒ£ Stack â€“ Balanced & Logical Stack Operations ğŸ§±

* Push, pop, peek operations
* Proper size and boundary handling
* Clear understanding of LIFO behavior

---

## ğŸ§© Key Concepts Strengthened

* Stack vs Queue use-cases
* Recursion with stack memory
* Sliding window technique
* Circular traversal logic
* Real-world problem modeling using abstract data structures
* Time & space complexity awareness

---


## ğŸ“˜ Week 3 â€“ Day 3: Strings, File Handling, Searching & Sorting in Java

On **Day 3 of Week 3**, I worked on **string manipulation**, **file I/O**, **searching techniques**, and **sorting algorithms** in Java with a focus on **best practices** and **interview-level problem solving**.

---

## ğŸ§  Key Concepts & Best Practices

### ğŸ”¹ String Handling

* Used **StringBuilder** for high-performance mutable strings
* Used **StringBuffer** for thread-safe operations
* Wrapped readers (FileReader / InputStreamReader) with **BufferedReader**

### ğŸ”¹ Searching Techniques

* **Linear Search** for unsorted data
* **Binary Search** for sorted data (overflow-safe mid calculation)

### ğŸ”¹ Sorting Algorithms

* **Bubble, Selection, Insertion**
* **Merge, Quick, Heap, Counting**
* Emphasis on **correct logic**, **time complexity**, and **use cases**

---

## ğŸ§ª Problems Solved

### ğŸ”¤ StringBuilder & StringBuffer

* Reverse string using StringBuilder
* Remove duplicates
* Efficient concatenation
* Performance comparison

### ğŸ“ File Handling

* Read file line-by-line
* Word occurrence count
* Convert byte stream to characters
* Console input write to file

### ğŸ” Searching

* First negative number
* Word search in sentences
* Rotation point in rotated array
* Peak element
* 2D matrix binary search
* First & last occurrence
* Combined linear & binary challenge

### ğŸ”ƒ Sorting

* Student marks (Bubble Sort)
* Employee IDs (Insertion Sort)
* Exam scores (Selection Sort)
* Book prices (Merge Sort)
* Product prices (Quick Sort)
* Salaries (Heap Sort)
* Student ages (Counting Sort)

---

## ğŸ”— Code Links

### ğŸ“‚ Searching Algorithms

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/binarysearch](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/binarysearch)

### ğŸ“‚ Sorting Algorithms

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/sortingalgorithm](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/sortingalgorithm)

---

## ğŸ›  Tools & Workflow

* **Java (Core)**
* **Eclipse IDE**
* **Git & GitHub**
* Clean, modular, interview-prepared code

---

## ğŸ“˜ Week 3 â€“ Day 4: Runtime Analysis & Big-O Optimization in Java

On **Day 4 of Week 3**, I focused on **Runtime Analysis and Big-O Notation**, comparing **time and space complexity** of different algorithms and data structures through **practical, performance-driven problems**.

The emphasis was on **choosing efficient algorithms**, **reducing unnecessary computations**, and **writing scalable Java code**.

---

## ğŸ§  Key Concepts & Best Practices

### ğŸ”¹ Algorithm Design & Optimization

* Selected the **right data structure** for performance
* Avoided unnecessary **nested loops**
* Used **early exit (break/return)** where applicable
* Reduced redundant computations using caching/memoization
* Preferred **iterative solutions** over expensive recursion

---

### ğŸ”¹ Time & Space Complexity Techniques

* Used **Binary Search (O(log N))** over Linear Search (O(N))
* Preferred **Merge Sort / Quick Sort (O(N log N))** over Bubble Sort
* Used **StringBuilder** instead of `String` for concatenation
* Used **primitive data types** to reduce memory overhead
* Benchmarked performance using `System.nanoTime()`

---

## ğŸ§ª Problems & Performance Comparisons

### ğŸ” Searching Large Datasets

* Linear Search vs Binary Search
* Observed drastic performance improvement with sorted data

---

### ğŸ”ƒ Sorting Large Data

* Bubble Sort vs Merge Sort vs Quick Sort
* Identified Bubble Sort as impractical for large datasets

---

### ğŸ”¤ String Concatenation Performance

* `String` vs `StringBuilder` vs `StringBuffer`
* Confirmed **StringBuilder** as best for single-threaded use

---

### ğŸ“ Large File Reading

* FileReader vs InputStreamReader
* InputStreamReader proved faster for large files

---

### ğŸ” Fibonacci Computation

* Recursive (O(2â¿)) vs Iterative (O(N))
* Iterative approach significantly faster and memory-efficient

---

### ğŸ—‚ Data Structure Lookup Comparison

* Array vs HashSet vs TreeSet
* HashSet fastest for search, TreeSet for ordered data

---

## ğŸ“Œ Learning Outcomes

âœ” Strong understanding of Big-O notation
âœ” Ability to compare algorithm efficiency
âœ” Improved decision-making for data structures
âœ” Optimized Java programs for scalability
âœ” Interview-ready runtime analysis skills

---

## ğŸ”— Code Link â€“ Runtime Analysis & Big-O

ğŸ‘‰ [https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/algoritmsruntimeanalysis](https://github.com/Shifa-Khan-05/BridgeLabz-Training/tree/java-dsa-practice/java-dsa-practice/gcr-codebase/javaDsaConcepts/src/com/algoritmsruntimeanalysis)

---


